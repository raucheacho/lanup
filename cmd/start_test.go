package cmd

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/raucheacho/lanup/internal/config"
	"github.com/raucheacho/lanup/internal/env"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestStartCmd_Run_Success(t *testing.T) {
	// Create temporary directory for test
	tmpDir := t.TempDir()

	// Change to temp directory
	originalWd, err := os.Getwd()
	require.NoError(t, err)
	defer os.Chdir(originalWd)

	err = os.Chdir(tmpDir)
	require.NoError(t, err)

	// Create test project config
	testConfig := &config.ProjectConfig{
		Vars: map[string]string{
			"API_URL":      "http://localhost:8000",
			"SUPABASE_URL": "http://localhost:54321",
		},
		Output: ".env.local",
		AutoDetect: config.AutoDetectConfig{
			Docker:   false,
			Supabase: false,
		},
	}

	configPath := filepath.Join(tmpDir, ".lanup.yaml")
	err = config.SaveProjectConfig(configPath, testConfig)
	require.NoError(t, err)

	// Create start command
	startCmd := &StartCmd{
		Watch:  false,
		NoEnv:  false,
		DryRun: false,
		Log:    false,
	}

	// Run start command
	err = startCmd.Run()
	require.NoError(t, err)

	// Verify .env.local was created
	envPath := filepath.Join(tmpDir, ".env.local")
	_, err = os.Stat(envPath)
	require.NoError(t, err, ".env.local should exist")

	// Read and verify content
	content, err := os.ReadFile(envPath)
	require.NoError(t, err)

	contentStr := string(content)

	// Verify header
	assert.Contains(t, contentStr, "# Generated by lanup on")
	assert.Contains(t, contentStr, "# Do not edit the managed variables manually")

	// Verify managed variables exist and are transformed
	assert.Contains(t, contentStr, "# lanup:managed")
	assert.Contains(t, contentStr, "API_URL=")
	assert.Contains(t, contentStr, "SUPABASE_URL=")

	// Verify localhost was replaced (should not contain localhost)
	assert.NotContains(t, contentStr, "localhost")
}

func TestStartCmd_Run_WithExistingEnv(t *testing.T) {
	// Create temporary directory for test
	tmpDir := t.TempDir()

	// Change to temp directory
	originalWd, err := os.Getwd()
	require.NoError(t, err)
	defer os.Chdir(originalWd)

	err = os.Chdir(tmpDir)
	require.NoError(t, err)

	// Create test project config
	testConfig := &config.ProjectConfig{
		Vars: map[string]string{
			"API_URL": "http://localhost:8000",
		},
		Output: ".env.local",
		AutoDetect: config.AutoDetectConfig{
			Docker:   false,
			Supabase: false,
		},
	}

	configPath := filepath.Join(tmpDir, ".lanup.yaml")
	err = config.SaveProjectConfig(configPath, testConfig)
	require.NoError(t, err)

	// Create existing .env.local with user variables
	envPath := filepath.Join(tmpDir, ".env.local")
	existingContent := `DATABASE_URL=postgresql://localhost:5432/db
SECRET_KEY=my-secret
`
	err = os.WriteFile(envPath, []byte(existingContent), 0644)
	require.NoError(t, err)

	// Create start command
	startCmd := &StartCmd{
		Watch:  false,
		NoEnv:  false,
		DryRun: false,
		Log:    false,
	}

	// Run start command
	err = startCmd.Run()
	require.NoError(t, err)

	// Verify backup was created
	backupPath := envPath + ".bak"
	_, err = os.Stat(backupPath)
	require.NoError(t, err, "Backup file should exist")

	// Verify backup content matches original
	backupContent, err := os.ReadFile(backupPath)
	require.NoError(t, err)
	assert.Equal(t, existingContent, string(backupContent))

	// Read and verify new content
	content, err := os.ReadFile(envPath)
	require.NoError(t, err)

	contentStr := string(content)

	// Verify managed variables were added
	assert.Contains(t, contentStr, "# lanup:managed")
	assert.Contains(t, contentStr, "API_URL=")

	// Verify user variables were preserved
	assert.Contains(t, contentStr, "DATABASE_URL=postgresql://localhost:5432/db")
	assert.Contains(t, contentStr, "SECRET_KEY=my-secret")
}

func TestStartCmd_Run_DryRun(t *testing.T) {
	// Create temporary directory for test
	tmpDir := t.TempDir()

	// Change to temp directory
	originalWd, err := os.Getwd()
	require.NoError(t, err)
	defer os.Chdir(originalWd)

	err = os.Chdir(tmpDir)
	require.NoError(t, err)

	// Create test project config
	testConfig := &config.ProjectConfig{
		Vars: map[string]string{
			"API_URL": "http://localhost:8000",
		},
		Output: ".env.local",
		AutoDetect: config.AutoDetectConfig{
			Docker:   false,
			Supabase: false,
		},
	}

	configPath := filepath.Join(tmpDir, ".lanup.yaml")
	err = config.SaveProjectConfig(configPath, testConfig)
	require.NoError(t, err)

	// Create start command with dry-run
	startCmd := &StartCmd{
		Watch:  false,
		NoEnv:  false,
		DryRun: true,
		Log:    false,
	}

	// Run start command
	err = startCmd.Run()
	require.NoError(t, err)

	// Verify .env.local was NOT created
	envPath := filepath.Join(tmpDir, ".env.local")
	_, err = os.Stat(envPath)
	assert.True(t, os.IsNotExist(err), ".env.local should not exist in dry-run mode")
}

func TestStartCmd_Run_NoEnv(t *testing.T) {
	// Create temporary directory for test
	tmpDir := t.TempDir()

	// Change to temp directory
	originalWd, err := os.Getwd()
	require.NoError(t, err)
	defer os.Chdir(originalWd)

	err = os.Chdir(tmpDir)
	require.NoError(t, err)

	// Create test project config
	testConfig := &config.ProjectConfig{
		Vars: map[string]string{
			"API_URL": "http://localhost:8000",
		},
		Output: ".env.local",
		AutoDetect: config.AutoDetectConfig{
			Docker:   false,
			Supabase: false,
		},
	}

	configPath := filepath.Join(tmpDir, ".lanup.yaml")
	err = config.SaveProjectConfig(configPath, testConfig)
	require.NoError(t, err)

	// Create start command with no-env
	startCmd := &StartCmd{
		Watch:  false,
		NoEnv:  true,
		DryRun: false,
		Log:    false,
	}

	// Run start command
	err = startCmd.Run()
	require.NoError(t, err)

	// Verify .env.local was NOT created
	envPath := filepath.Join(tmpDir, ".env.local")
	_, err = os.Stat(envPath)
	assert.True(t, os.IsNotExist(err), ".env.local should not exist with --no-env flag")
}

func TestStartCmd_Run_MissingConfig(t *testing.T) {
	// Create temporary directory for test
	tmpDir := t.TempDir()

	// Change to temp directory
	originalWd, err := os.Getwd()
	require.NoError(t, err)
	defer os.Chdir(originalWd)

	err = os.Chdir(tmpDir)
	require.NoError(t, err)

	// Create start command (no config file exists)
	startCmd := &StartCmd{
		Watch:  false,
		NoEnv:  false,
		DryRun: false,
		Log:    false,
	}

	// Run start command
	err = startCmd.Run()
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "Failed to load project configuration")
}

func TestStartCmd_ExecuteStart_PreservesUserVariables(t *testing.T) {
	// Create temporary directory for test
	tmpDir := t.TempDir()

	// Change to temp directory
	originalWd, err := os.Getwd()
	require.NoError(t, err)
	defer os.Chdir(originalWd)

	err = os.Chdir(tmpDir)
	require.NoError(t, err)

	// Create test project config
	testConfig := &config.ProjectConfig{
		Vars: map[string]string{
			"API_URL": "http://localhost:8000",
		},
		Output: ".env.local",
		AutoDetect: config.AutoDetectConfig{
			Docker:   false,
			Supabase: false,
		},
	}

	configPath := filepath.Join(tmpDir, ".lanup.yaml")
	err = config.SaveProjectConfig(configPath, testConfig)
	require.NoError(t, err)

	// Create existing .env.local with managed and user variables
	envPath := filepath.Join(tmpDir, ".env.local")
	existingContent := `# Generated by lanup on 2025-10-27 12:00:00
# Do not edit the managed variables manually

# lanup:managed
API_URL=http://192.168.1.50:8000

# User variables (preserved)
DATABASE_URL=postgresql://localhost:5432/db
SECRET_KEY=my-secret
CUSTOM_VAR=custom-value
`
	err = os.WriteFile(envPath, []byte(existingContent), 0644)
	require.NoError(t, err)

	// Create start command
	startCmd := &StartCmd{
		Watch:  false,
		NoEnv:  false,
		DryRun: false,
		Log:    false,
	}

	// Run start command
	err = startCmd.Run()
	require.NoError(t, err)

	// Read the updated env file
	envWriter := env.NewEnvWriter(envPath)
	vars, err := envWriter.Read()
	require.NoError(t, err)

	// Create maps for easier verification
	varMap := make(map[string]env.EnvVar)
	for _, v := range vars {
		varMap[v.Key] = v
	}

	// Verify API_URL was updated and is managed
	apiURL, exists := varMap["API_URL"]
	assert.True(t, exists)
	assert.True(t, apiURL.Managed)
	assert.NotContains(t, apiURL.Value, "localhost")

	// Verify user variables were preserved and are not managed
	dbURL, exists := varMap["DATABASE_URL"]
	assert.True(t, exists)
	assert.False(t, dbURL.Managed)
	assert.Equal(t, "postgresql://localhost:5432/db", dbURL.Value)

	secretKey, exists := varMap["SECRET_KEY"]
	assert.True(t, exists)
	assert.False(t, secretKey.Managed)
	assert.Equal(t, "my-secret", secretKey.Value)

	customVar, exists := varMap["CUSTOM_VAR"]
	assert.True(t, exists)
	assert.False(t, customVar.Managed)
	assert.Equal(t, "custom-value", customVar.Value)
}

func TestTransformURL(t *testing.T) {
	tests := []struct {
		name  string
		url   string
		newIP string
	}{
		{
			name:  "replace localhost",
			url:   "http://localhost:8000",
			newIP: "192.168.1.100",
		},
		{
			name:  "replace 127.0.0.1",
			url:   "http://127.0.0.1:8000",
			newIP: "192.168.1.100",
		},
		{
			name:  "replace localhost with https",
			url:   "https://localhost:8443",
			newIP: "192.168.1.100",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := transformURL(tt.url, tt.newIP)

			// Verify localhost was replaced
			assert.NotContains(t, result, "localhost")
			assert.NotContains(t, result, "127.0.0.1")

			// Verify new IP is in the result
			assert.Contains(t, result, tt.newIP)

			// Verify protocol is preserved
			if strings.HasPrefix(tt.url, "https") {
				assert.True(t, strings.HasPrefix(result, "https"))
			} else {
				assert.True(t, strings.HasPrefix(result, "http"))
			}
		})
	}
}
